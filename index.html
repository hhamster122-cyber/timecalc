<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Time Converter</title>
  <style>
    :root { --bg:#f8fafc; --fg:#0f172a; --muted:#64748b; --card:#fff; --br:#e2e8f0; --pri:#4f46e5; }
    * { box-sizing:border-box; }
    body { margin:0; font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--fg); }
    .wrap { max-width:960px; margin:0 auto; padding:16px; }
    h1 { font-size:22px; margin:0 0 6px; }
    .note { color:var(--muted); margin:0 0 12px; font-size:14px; }
    .section { margin:12px 0; }
    .title { font-weight:700; margin:0 0 8px; font-size:15px; text-transform:uppercase; letter-spacing:.02em; color:#334155; }
    .grid2 { display:grid; gap:12px; grid-template-columns:1fr; }
    .grid3 { display:grid; gap:12px; grid-template-columns:1fr; }
    @media (min-width:800px){ .grid2{ grid-template-columns:1.2fr 1fr; } .grid3{ grid-template-columns:1fr 1fr 1fr; } }
    .card { background:var(--card); border:1px solid var(--br); border-radius:16px; padding:12px; }
    label { display:block; font-weight:600; margin:0 0 6px; font-size:14px; }
    input[type="text"], input[type="datetime-local"], select { width:100%; border:1px solid var(--br); border-radius:12px; padding:10px 12px; font-size:16px; }
    .row { display:flex; gap:8px; align-items:center; }
    .btn { border:1px solid var(--br); background:#fff; border-radius:12px; padding:10px 14px; font-size:15px; cursor:pointer; }
    .btn:hover { background:#f1f5f9; }
    .zones { height:210px; overflow:auto; border:1px solid var(--br); border-radius:12px; }
    .zones button { display:block; width:100%; border:0; background:transparent; text-align:left; padding:10px 12px; font-size:14px; cursor:pointer; }
    .zones button:hover { background:#f8fafc; }
    .zones button.active { background:#eef2ff; font-weight:600; }
    .muted { color:var(--muted); font-size:13px; }
    .big { font-size:20px; font-weight:700; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .break { word-break:break-all; }
    .warn { color:#b91c1c; }
    .tabs { display:flex; gap:8px; margin:6px 0 8px; }
    .tab { padding:6px 10px; border:1px solid var(--br); border-radius:999px; cursor:pointer; font-size:13px; }
    .tab.active { background:#eef2ff; font-weight:600; }
    .hidden { display:none; }

    /* Sticky actions on mobile */
    .actions { position:sticky; bottom:0; background:rgba(248,250,252,.88); backdrop-filter:saturate(1.2) blur(6px); padding:10px; border-top:1px solid var(--br); display:flex; gap:8px; justify-content:flex-end; border-radius:0 0 16px 16px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#1f2a6b; font-size:12px; margin-left:6px; }

    /* Reduce scrolling */
    @media (max-width:799px){
      .wrap { padding:10px; }
      input, select, .btn { min-height:44px; }
      .zones { height:240px; }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <header class="section">
      <h1 id="title">–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –≤—Ä–µ–º–µ–Ω–∏: UTC ‚Üí –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å</h1>
      <div id="note" class="note">–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É/–≤—Ä–µ–º—è —Å–æ–±—ã—Ç–∏—è –ø–æ UTC –∏ –ø–æ–ª—É—á–∏—Ç–µ –º–µ—Å—Ç–Ω–æ–µ –≤—Ä–µ–º—è. ¬´–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è¬ª –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–¥—É—Ç —Ä—è–¥–æ–º; ¬´–ù–∞—Å—Ç—Ä–æ–π–∫–∏¬ª ‚Äî –æ—Ç–¥–µ–ª—å–Ω–æ.</div>
    </header>

    <!-- Conversion: UTC input + result close together -->
    <section class="section">
      <div class="title" id="title_conv">–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è</div>
      <div class="grid2">
        <div class="card">
          <label id="label_input">–í—Ä–µ–º—è —Å–æ–±—ã—Ç–∏—è (UTC)</label>
          <div class="tabs">
            <div id="tabPicker" class="tab active">–ü—Ä–æ–∫—Ä—É—Ç–∫–∞</div>
            <div id="tabText" class="tab">–í–≤–æ–¥</div>
          </div>

          <!-- Picker mode -->
          <div id="pickerBox">
            <input id="utcPicker" type="datetime-local" step="60" />
            <p class="muted" id="hint_picker">–ó–Ω–∞—á–µ–Ω–∏–µ —Ç—Ä–∞–∫—Ç—É–µ—Ç—Å—è –∫–∞–∫ UTC –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.</p>
          </div>

          <!-- Text mode -->
          <div id="textBox" class="hidden">
            <input id="utcInput" type="text" inputmode="numeric" placeholder="01.12.2025 18:30" />
            <p id="hint_input" class="muted">–§–æ—Ä–º–∞—Ç: <span id="fmtBadge" class="badge mono">–î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú</span> (–∞–≤—Ç–æ –ø–æ —Ä–µ–≥–∏–æ–Ω—É). –ú–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å ISO <span class="mono">2025-11-05T14:00</span>.</p>
            <p id="input_err" class="muted warn" style="display:none;"></p>
          </div>
        </div>

        <div class="card">
          <label id="label_result">–†–µ–∑—É–ª—å—Ç–∞—Ç</label>
          <div id="outLocal" class="big" aria-live="polite">‚Äî</div>
          <div id="outTz" class="muted mono"></div>
          <div class="muted" style="margin-top:6px;"><span id="label_now">–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è:</span> <span id="outNow"></span></div>
          <div class="actions">
            <button class="btn" id="btnCopy">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
            <button class="btn" id="btnOpen">–û—Ç–∫—Ä—ã—Ç—å</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Setup: timezone, language, date format override -->
    <section class="section">
      <div class="title" id="title_setup">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>
      <div class="grid3">
        <div class="card">
          <label id="label_tz">–í–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å</label>
          <div class="row" style="margin-bottom:8px;">
            <input id="tzSearch" type="text" placeholder="–ü–æ–∏—Å–∫ (Europe/Moscow, America/New_York‚Ä¶)" />
            <button class="btn" id="btnAuto">–ê–≤—Ç–æ</button>
          </div>
          <div class="zones" id="zoneList"></div>
        </div>

        <div class="card">
          <label id="label_lang">–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</label>
          <select id="lang">
            <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
            <option value="en">üá¨üáß English</option>
            <option value="es">üá™üá∏ Espa√±ol</option>
            <option value="it">üáÆüáπ Italiano</option>
            <option value="nl">üá≥üá± Nederlands</option>
          </select>
          <p class="muted" id="hint_lang">–¢–µ–∫—Å—Ç–æ–≤—ã–µ –ø–æ–¥–ø–∏—Å–∏ –∏ —Ñ–æ—Ä–º–∞—Ç –≤—ã–≤–æ–¥–∞ –º–µ–Ω—è—é—Ç—Å—è –ø–æ —è–∑—ã–∫—É.</p>
        </div>

        <div class="card">
          <label id="label_df">–§–æ—Ä–º–∞—Ç –¥–∞—Ç—ã (–≤–≤–æ–¥)</label>
          <select id="dateFormat">
            <option value="auto">–ê–≤—Ç–æ (–ø–æ —Ä–µ–≥–∏–æ–Ω—É)</option>
            <option value="MDY">MM/DD/YYYY</option>
            <option value="DMY">DD/MM/YYYY</option>
            <option value="D.M.Y">DD.MM.YYYY</option>
            <option value="YMD">YYYY-MM-DD</option>
          </select>
          <p class="muted" id="hint_df">–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞.</p>
        </div>
      </div>
    </section>

    <section class="section card">
      <label id="label_share">–ü–æ–¥–µ–ª–∏—Ç—å—Å—è</label>
      <div id="share" class="mono break" style="margin:8px 0 8px;"></div>
    </section>
  </main>

  <script>
    const SUPPORTED = ['ru','en','es','it','nl'];
    const DICT = {
      ru: {
        title: "–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –≤—Ä–µ–º–µ–Ω–∏: UTC ‚Üí –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å",
        note: "–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É/–≤—Ä–µ–º—è —Å–æ–±—ã—Ç–∏—è –ø–æ UTC –∏ –ø–æ–ª—É—á–∏—Ç–µ –º–µ—Å—Ç–Ω–æ–µ –≤—Ä–µ–º—è. ¬´–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è¬ª –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–¥—É—Ç —Ä—è–¥–æ–º; ¬´–ù–∞—Å—Ç—Ä–æ–π–∫–∏¬ª ‚Äî –æ—Ç–¥–µ–ª—å–Ω–æ.",
        conv: "–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è",
        setup: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
        input_label: "–í—Ä–µ–º—è —Å–æ–±—ã—Ç–∏—è (UTC)",
        picker_hint: "–ó–Ω–∞—á–µ–Ω–∏–µ —Ç—Ä–∞–∫—Ç—É–µ—Ç—Å—è –∫–∞–∫ UTC –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.",
        text_hint: "–§–æ—Ä–º–∞—Ç: {fmt} (–∞–≤—Ç–æ –ø–æ —Ä–µ–≥–∏–æ–Ω—É). –ú–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å ISO 2025-11-05T14:00.",
        text_err: "–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é –¥–∞—Ç—É/–≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ {fmt} (UTC).",
        tz_label: "–í–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å",
        search_placeholder: "–ü–æ–∏—Å–∫ (Europe/Moscow, America/New_York‚Ä¶)",
        auto_btn: "–ê–≤—Ç–æ",
        result: "–†–µ–∑—É–ª—å—Ç–∞—Ç",
        relative: "–û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å–µ–π—á–∞—Å",
        current_time: "–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è:",
        share: "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è",
        copy: "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É",
        open: "–û—Ç–∫—Ä—ã—Ç—å",
        lang_label: "–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞",
        lang_hint: "–¢–µ–∫—Å—Ç–æ–≤—ã–µ –ø–æ–¥–ø–∏—Å–∏ –∏ —Ñ–æ—Ä–º–∞—Ç –≤—ã–≤–æ–¥–∞ –º–µ–Ω—è—é—Ç—Å—è –ø–æ —è–∑—ã–∫—É.",
        df_label: "–§–æ—Ä–º–∞—Ç –¥–∞—Ç—ã (–≤–≤–æ–¥)",
        df_hint: "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞.",
        tab_picker: "–ü—Ä–æ–∫—Ä—É—Ç–∫–∞",
        tab_text: "–í–≤–æ–¥",
      },
      en: {
        title: "Time Converter: UTC ‚Üí your time zone",
        note: "Pick UTC date/time and see your local time. ‚ÄúConversion‚Äù and result are close; ‚ÄúSetup‚Äù is separate.",
        conv: "Conversion",
        setup: "Setup",
        input_label: "Event time (UTC)",
        picker_hint: "Value is treated as UTC regardless of your device time zone.",
        text_hint: "Format: {fmt} (auto by region). ISO 2025-11-05T14:00 is also accepted.",
        text_err: "Please enter a valid UTC date/time in {fmt}.",
        tz_label: "Your time zone",
        search_placeholder: "Search (Europe/Moscow, America/New_York‚Ä¶)",
        auto_btn: "Auto",
        result: "Result",
        relative: "Relative to now",
        current_time: "Current time:",
        share: "Share",
        copy: "Copy link",
        open: "Open",
        lang_label: "Interface language",
        lang_hint: "Labels and output format follow the language.",
        df_label: "Date format (input)",
        df_hint: "By default it is chosen automatically from selected time zone.",
        tab_picker: "Wheel",
        tab_text: "Text",
      },
      es: {
        title: "Conversor de hora: UTC ‚Üí tu zona horaria",
        note: "Selecciona la hora en UTC y ver√°s tu hora local. ¬´Conversi√≥n¬ª y resultado van juntos; ¬´Ajustes¬ª aparte.",
        conv: "Conversi√≥n",
        setup: "Ajustes",
        input_label: "Hora del evento (UTC)",
        picker_hint: "Se considera UTC independientemente de la zona horaria del dispositivo.",
        text_hint: "Formato: {fmt} (auto por regi√≥n). Tambi√©n se acepta ISO 2025-11-05T14:00.",
        text_err: "Introduce una fecha/hora UTC v√°lida en formato {fmt}.",
        tz_label: "Tu zona horaria",
        search_placeholder: "Buscar (Europe/Moscow, America/New_York‚Ä¶)",
        auto_btn: "Auto",
        result: "Resultado",
        relative: "En relaci√≥n con ahora",
        current_time: "Hora actual:",
        share: "Compartir",
        copy: "Copiar enlace",
        open: "Abrir",
        lang_label: "Idioma de la interfaz",
        lang_hint: "Las etiquetas y el formato de salida siguen el idioma.",
        df_label: "Formato de fecha (entrada)",
        df_hint: "Por defecto se elige autom√°ticamente seg√∫n la zona horaria seleccionada.",
        tab_picker: "Selector",
        tab_text: "Texto",
      },
      it: {
        title: "Convertitore orario: UTC ‚Üí il tuo fuso orario",
        note: "Seleziona l'orario UTC e vedi l'ora locale. ¬´Conversione¬ª e risultato sono vicini; ¬´Impostazioni¬ª separato.",
        conv: "Conversione",
        setup: "Impostazioni",
        input_label: "Orario dell'evento (UTC)",
        picker_hint: "√à considerato UTC indipendentemente dal fuso orario del dispositivo.",
        text_hint: "Formato: {fmt} (auto per regione). Accetta anche ISO 2025-11-05T14:00.",
        text_err: "Inserisci una data/ora UTC valida nel formato {fmt}.",
        tz_label: "Il tuo fuso orario",
        search_placeholder: "Cerca (Europe/Moscow, America/New_York‚Ä¶)",
        auto_btn: "Auto",
        result: "Risultato",
        relative: "Rispetto a ora",
        current_time: "Ora attuale:",
        share: "Condividi",
        copy: "Copia link",
        open: "Apri",
        lang_label: "Lingua dell'interfaccia",
        lang_hint: "Le etichette e il formato di output seguono la lingua.",
        df_label: "Formato data (input)",
        df_hint: "Per impostazione predefinita √® scelto automaticamente dalla zona oraria selezionata.",
        tab_picker: "Rotella",
        tab_text: "Testo",
      },
      nl: {
        title: "Tijdconverter: UTC ‚Üí jouw tijdzone",
        note: "Kies de UTC-tijd en bekijk je lokale tijd. ‚ÄòConversie‚Äô en resultaat staan dicht bij elkaar; ‚ÄòInstellingen‚Äô apart.",
        conv: "Conversie",
        setup: "Instellingen",
        input_label: "Gebeurtenistijd (UTC)",
        picker_hint: "Wordt gezien als UTC, ongeacht de tijdzone van het apparaat.",
        text_hint: "Formaat: {fmt} (automatisch per regio). ISO 2025-11-05T14:00 wordt ook geaccepteerd.",
        text_err: "Voer een geldige UTC-datum/tijd in {fmt} in.",
        tz_label: "Jouw tijdzone",
        search_placeholder: "Zoeken (Europe/Moscow, America/New_York‚Ä¶)",
        auto_btn: "Auto",
        result: "Resultaat",
        relative: "Ten opzichte van nu",
        current_time: "Huidige tijd:",
        share: "Delen",
        copy: "Link kopi√´ren",
        open: "Openen",
        lang_label: "Interfacetaal",
        lang_hint: "Labels en uitvoerformaat volgen de taal.",
        df_label: "Datumnotatie (invoer)",
        df_hint: "Standaard wordt dit automatisch gekozen op basis van de geselecteerde tijdzone.",
        tab_picker: "Wieltjes",
        tab_text: "Tekst",
      },
    };

    // Date format enums
    const DF = { AUTO:'auto', MDY:'MDY', DMY:'DMY', DMY_DOT:'D.M.Y', YMD:'YMD' };

    let state = {
      tz: getUserTZ(),
      lang: getInitialLang(),
      pickerISO: isoNowRoundedToMinutesUTC(), // YYYY-MM-DDTHH:mm (UTC wall time)
      textUTC: "", // user typed string
      mode: 'picker', // 'picker' | 'text'
      dateFormat: DF.AUTO, // input format override
    };

    const $ = (id) => document.getElementById(id);

    function init(){
      // Language
      const selLang = $('lang');
      selLang.value = state.lang;
      selLang.addEventListener('change', ()=>{
        state.lang = selLang.value;
        localStorage.setItem('calc_lang', state.lang);
        applyLang();
        update();
      });

      // Tabs
      $('tabPicker').addEventListener('click', ()=>setMode('picker'));
      $('tabText').addEventListener('click', ()=>setMode('text'));

      // Inputs
      $('utcPicker').value = state.pickerISO;
      $('utcPicker').addEventListener('input', (e)=>{ state.pickerISO = e.target.value; update(); });
      $('utcInput').addEventListener('input', onManualInputMask);

      // Timezones
      $('btnAuto').addEventListener('click', ()=>{ state.tz = getUserTZ(); renderZones(getAllZones()); markActiveTZ(); updateMaskBadge(); update(); });
      $('tzSearch').addEventListener('input', (e)=>{ renderZones(filterZones(e.target.value.trim().toLowerCase())); });

      renderZones(getAllZones());
      readQuery();
      $('utcPicker').value = state.pickerISO;
      $('utcInput').value = state.textUTC;

      // Date format override
      const selDf = $('dateFormat');
      selDf.value = state.dateFormat;
      selDf.addEventListener('change', ()=>{ state.dateFormat = selDf.value; updateMaskBadge(); update(); });

      applyLang();
      setMode(state.mode);
      updateMaskBadge();
      update();
      setInterval(()=> updateNow(), 30*1000);
    }

    function setMode(m){
      state.mode = m;
      $('tabPicker').classList.toggle('active', m==='picker');
      $('tabText').classList.toggle('active', m==='text');
      $('pickerBox').classList.toggle('hidden', m!=='picker');
      $('textBox').classList.toggle('hidden', m!=='text');
    }

    function getInitialLang(){
      const urlLang = new URL(location.href).searchParams.get('lang');
      if (urlLang && SUPPORTED.includes(urlLang)) return urlLang;
      const saved = localStorage.getItem('calc_lang');
      if (saved && SUPPORTED.includes(saved)) return saved;
      const browser = (navigator.language || 'ru').slice(0,2);
      return SUPPORTED.includes(browser) ? browser : 'ru';
    }

    function applyLang(){
      const t = DICT[state.lang];
      document.documentElement.lang = state.lang;
      document.title = t.title;
      $('title').textContent = t.title;
      $('note').textContent = t.note;
      $('title_conv').textContent = t.conv;
      $('title_setup').textContent = t.setup;

      $('label_input').textContent = t.input_label;
      $('hint_picker').textContent = t.picker_hint;
      $('hint_input').innerHTML = t.text_hint.replace('{fmt}', `<span class="badge mono">${getFormatLabel(getActiveDf())} HH:mm</span>`);
      $('input_err').style.display = 'none';
      $('input_err').textContent = t.text_err.replace('{fmt}', getFormatLabel(getActiveDf()) + ' HH:mm');

      $('label_tz').textContent = t.tz_label;
      $('tzSearch').placeholder = t.search_placeholder;
      $('btnAuto').textContent = `${t.auto_btn}`;

      $('label_result').textContent = t.result;
      $('label_now').textContent = t.current_time;
      $('label_share').textContent = t.share;

      $('label_lang').textContent = t.lang_label;
      $('hint_lang').textContent = t.lang_hint;

      $('label_df').textContent = t.df_label;
      $('hint_df').textContent = t.df_hint;

      $('tabPicker').textContent = t.tab_picker;
      $('tabText').textContent = t.tab_text;
    }

    // ===== Timezones =====
    function getUserTZ(){
      try { return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC'; } catch { return 'UTC'; }
    }

    function getAllZones(){
      if (typeof Intl.supportedValuesOf === 'function') {
        const list = Intl.supportedValuesOf('timeZone');
        const user = getUserTZ();
        return [user, ...list.filter(z => z !== user)];
      }
      return ['UTC','Europe/Moscow','Europe/Amsterdam','Europe/Madrid','Europe/Rome','America/New_York','America/Chicago','Europe/London','America/Denver','America/Los_Angeles','Asia/Tokyo','Asia/Shanghai','Asia/Dubai','Australia/Sydney'];
    }

    function filterZones(q){
      const zones = getAllZones();
      if (!q) return zones;
      return zones.filter(z => z.toLowerCase().includes(q));
    }

    function renderZones(list){
      const box = $('zoneList');
      box.innerHTML = '';
      list.forEach(z => {
        const b = document.createElement('button');
        b.textContent = z;
        b.className = (z===state.tz) ? 'active' : '';
        b.addEventListener('click', ()=>{ state.tz = z; markActiveTZ(); updateMaskBadge(); update(); });
        box.appendChild(b);
      });
      markActiveTZ();
    }

    function markActiveTZ(){
      [...$('zoneList').querySelectorAll('button')].forEach(b => {
        b.classList.toggle('active', b.textContent===state.tz);
      });
    }

    // ===== Date format logic =====
    const DF = { AUTO:'auto', MDY:'MDY', DMY:'DMY', DMY_DOT:'D.M.Y', YMD:'YMD' };

    function getActiveDf(){
      if (state.dateFormat !== DF.AUTO) return state.dateFormat;
      return inferDfFromTZ(state.tz);
    }

    function getFormatLabel(df){
      switch(df){
        case DF.MDY: return 'MM/DD/YYYY';
        case DF.DMY: return 'DD/MM/YYYY';
        case DF.DMY_DOT: return 'DD.MM.YYYY';
        case DF.YMD: return 'YYYY-MM-DD';
        default: return 'DD/MM/YYYY';
      }
    }

    // Heuristic mapping TZ ‚Üí common input format
    function inferDfFromTZ(tz){
      if (!tz) return DF.DMY;
      if (tz.startsWith('America/')) {
        const city = tz.split('/')[1] || '';
        const mdyUS = ['New_York','Detroit','Chicago','Denver','Phoenix','Los_Angeles','Anchorage','Toronto','Vancouver','Halifax','Winnipeg','Edmonton','Regina','Moncton','Boise','Indiana','Kentucky','Montreal','Calgary','Ottawa'];
        if (mdyUS.some(c => city.includes(c))) return DF.MDY;
        return DF.DMY; // Latin America default
      }
      if (tz.startsWith('Europe/')) {
        const city = tz.split('/')[1] || '';
        if (['Moscow','Kaliningrad','Samara'].includes(city)) return DF.DMY_DOT;
        return DF.DMY;
      }
      if (tz.startsWith('Asia/')) {
        const city = tz.split('/')[1] || '';
        const ymdCities = ['Tokyo','Seoul','Shanghai','Taipei','Hong_Kong','Singapore'];
        if (ymdCities.includes(city)) return DF.YMD;
        return DF.DMY;
      }
      return DF.DMY;
    }

    function updateMaskBadge(){
      const df = getActiveDf();
      $('fmtBadge').textContent = getFormatLabel(df) + ' HH:mm';
      const t = DICT[state.lang];
      $('hint_input').innerHTML = t.text_hint.replace('{fmt}', `<span class="badge mono">${getFormatLabel(df)} HH:mm</span>`);
      $('input_err').textContent = t.text_err.replace('{fmt}', getFormatLabel(df) + ' HH:mm');
    }

    // ===== Input masking & parsing =====
    function onManualInputMask(e){
      const raw = e.target.value;
      if (/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(raw)) { state.textUTC = raw; update(); return; }
      const digits = raw.replace(/\D/g,'');
      const df = getActiveDf();
      let out='';
      if (df === DF.MDY){
        if (digits.length>0) out += digits.slice(0,2);
        if (digits.length>=3) out += '/' + digits.slice(2,4);
        if (digits.length>=5) out += '/' + digits.slice(4,8);
        if (digits.length>=9) out += ' ' + digits.slice(8,10);
        if (digits.length>=11) out += ':' + digits.slice(10,12);
      } else if (df === DF.DMY){
        if (digits.length>0) out += digits.slice(0,2);
        if (digits.length>=3) out += '/' + digits.slice(2,4);
        if (digits.length>=5) out += '/' + digits.slice(4,8);
        if (digits.length>=9) out += ' ' + digits.slice(8,10);
        if (digits.length>=11) out += ':' + digits.slice(10,12);
      } else if (df === DF.DMY_DOT){
        if (digits.length>0) out += digits.slice(0,2);
        if (digits.length>=3) out += '.' + digits.slice(2,4);
        if (digits.length>=5) out += '.' + digits.slice(4,8);
        if (digits.length>=9) out += ' ' + digits.slice(8,10);
        if (digits.length>=11) out += ':' + digits.slice(10,12);
      } else if (df === DF.YMD){
        if (digits.length>0) out += digits.slice(0,4);
        if (digits.length>=5) out += '-' + digits.slice(4,6);
        if (digits.length>=7) out += '-' + digits.slice(6,8);
        if (digits.length>=9) out += ' ' + digits.slice(8,10);
        if (digits.length>=11) out += ':' + digits.slice(10,12);
      }
      e.target.value = out;
      state.textUTC = out;
      update();
    }

    function parseByActiveFormat(txt){
      const df = getActiveDf();
      return parseByFormat(txt, df) || parseFallbacks(txt);
    }

    function parseByFormat(txt, df){
      const s = (txt||'').replace(/T/, ' ').replace(/\s+/, ' ').trim();
      try {
        if (df === DF.MDY){
          const m = s.match(/^(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2})$/);
          if (!m) return null;
          const MM=+m[1], DD=+m[2], YYYY=+m[3], hh=+m[4], mm=+m[5];
          if (MM<1||MM>12||DD<1||DD>31||hh>23||mm>59) return null;
          return new Date(Date.UTC(YYYY, MM-1, DD, hh, mm, 0, 0));
        } else if (df === DF.DMY){
          const m = s.match(/^(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2})$/);
          if (!m) return null;
          const DD=+m[1], MM=+m[2], YYYY=+m[3], hh=+m[4], mm=+m[5];
          if (MM<1||MM>12||DD<1||DD>31||hh>23||mm>59) return null;
          return new Date(Date.UTC(YYYY, MM-1, DD, hh, mm, 0, 0));
        } else if (df === DF.DMY_DOT){
          const m = s.match(/^(\d{2})\.(\d{2})\.(\d{4})\s+(\d{2}):(\d{2})$/);
          if (!m) return null;
          const DD=+m[1], MM=+m[2], YYYY=+m[3], hh=+m[4], mm=+m[5];
          if (MM<1||MM>12||DD<1||DD>31||hh>23||mm>59) return null;
          return new Date(Date.UTC(YYYY, MM-1, DD, hh, mm, 0, 0));
        } else if (df === DF.YMD){
          const m = s.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})$/);
          if (!m) return null;
          const YYYY=+m[1], MM=+m[2], DD=+m[3], hh=+m[4], mm=+m[5];
          if (MM<1||MM>12||DD<1||DD>31||hh>23||mm>59) return null;
          return new Date(Date.UTC(YYYY, MM-1, DD, hh, mm, 0, 0));
        }
      } catch { return null; }
      return null;
    }

    function parseFallbacks(txt){
      const s = (txt||'').trim();
      const iso = s.replace(' ', 'T').slice(0,16);
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(iso)){
        const [d,t] = iso.split('T');
        const [y,m,dd] = d.split('-').map(Number);
        const [hh,mm] = t.split(':').map(Number);
        return new Date(Date.UTC(y,(m||1)-1,dd||1,hh||0,mm||0,0,0));
      }
      const dot = s.match(/^(\d{2})\.(\d{2})\.(\d{4})\s+(\d{2}):(\d{2})$/);
      if (dot){
        const DD=+dot[1], MM=+dot[2], YYYY=+dot[3], hh=+dot[4], mm=+dot[5];
        if (MM>=1&&MM<=12&&DD>=1&&DD<=31&&hh<=23&&mm<=59) return new Date(Date.UTC(YYYY,MM-1,DD,hh,mm,0,0));
      }
      return null;
    }

    // ===== Core update/render =====
    function readQuery(){
      const u = new URL(location.href);
      const qUtc = u.searchParams.get('utc');   // ISO
      const qTz = u.searchParams.get('tz');
      const qLang = u.searchParams.get('lang');
      const qDf = u.searchParams.get('df');
      if (qUtc) {
        const d = parseISOToUTC(qUtc);
        if (d){
          state.pickerISO = qUtc.slice(0,16);
          state.textUTC = toByDf(d, getActiveDf());
        }
      }
      if (qTz && getAllZones().includes(qTz)) state.tz = qTz;
      if (qLang && SUPPORTED.includes(qLang)) state.lang = qLang;
      if (qDf && Object.values(DF).includes(qDf)) state.dateFormat = qDf;
      $('lang').value = state.lang;
      $('dateFormat').value = state.dateFormat;
    }

    function update(){
      const t = DICT[state.lang];
      let d = null;
      if (state.mode === 'picker'){
        const iso = (state.pickerISO||'').trim();
        d = parseISOToUTC(iso);
        if (!d){
          $('outLocal').textContent = '‚Äî';
          $('outTz').textContent = state.tz;
          $('outNow').textContent = formatInTZ(new Date(), state.tz, state.lang);
        }else{
          $('outLocal').textContent = formatInTZ(d, state.tz, state.lang);
          $('outTz').textContent = state.tz;
          $('outNow').textContent = formatInTZ(new Date(), state.tz, state.lang);
        }
        $('input_err').style.display = 'none';
      } else {
        const txt = (state.textUTC||'').trim();
        d = parseByActiveFormat(txt);
        if (!d){
          $('outLocal').textContent = '‚Äî';
          $('outTz').textContent = state.tz;
          $('input_err').style.display = 'block';
          $('input_err').textContent = t.text_err.replace('{fmt}', getFormatLabel(getActiveDf()) + ' HH:mm');
        }else{
          $('input_err').style.display = 'none';
          $('outLocal').textContent = formatInTZ(d, state.tz, state.lang);
          $('outTz').textContent = state.tz;
        }
        $('outNow').textContent = formatInTZ(new Date(), state.tz, state.lang);
      }
      $('share').textContent = getShareURL();
      try { history.replaceState(null, '', getShareURL()); } catch (e) {}
    }

    function updateNow(){ $('outNow').textContent = formatInTZ(new Date(), state.tz, state.lang); }

    function getShareURL(){
      const u = new URL(location.href);
      let d = null;
      if (state.mode==='picker'){
        d = parseISOToUTC(state.pickerISO);
      } else {
        d = parseByActiveFormat(state.textUTC);
      }
      if (d) u.searchParams.set('utc', toISO_UTC_Min(d)); else u.searchParams.delete('utc');
      u.searchParams.set('tz', state.tz);
      u.searchParams.set('lang', state.lang);
      u.searchParams.set('df', state.dateFormat);
      return u.toString();
    }

    // ===== Utilities =====
    function isoNowRoundedToMinutesUTC(){
      const now = new Date();
      const ms = 60000;
      const t = Math.floor(now.getTime()/ms)*ms;
      const d = new Date(t);
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth()+1).padStart(2,'0');
      const dd = String(d.getUTCDate()).padStart(2,'0');
      const hh = String(d.getUTCHours()).padStart(2,'0');
      const mm = String(d.getUTCMinutes()).padStart(2,'0');
      return `${y}-${m}-${dd}T${hh}:${mm}`;
    }

    function parseISOToUTC(txt){
      const s = (txt||'').replace(' ', 'T').slice(0,16);
      if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(s)) return null;
      const [d,t] = s.split('T');
      const [y,m,dd] = d.split('-').map(Number);
      const [hh,mm] = t.split(':').map(Number);
      return new Date(Date.UTC(y,(m||1)-1,dd||1,hh||0,mm||0,0,0));
    }

    function toISO_UTC_Min(date){
      const pad = (n)=> String(n).padStart(2,'0');
      const y = date.getUTCFullYear();
      const m = pad(date.getUTCMonth()+1);
      const d = pad(date.getUTCDate());
      const hh = pad(date.getUTCHours());
      const mm = pad(date.getUTCMinutes());
      return `${y}-${m}-${d}T${hh}:${mm}`;
    }

    function toByDf(date, df){
      const pad = (n)=> String(n).padStart(2,'0');
      const YYYY = date.getUTCFullYear();
      const MM = pad(date.getUTCMonth()+1);
      const DD = pad(date.getUTCDate());
      const hh = pad(date.getUTCHours());
      const mm = pad(date.getUTCMinutes());
      if (df==='MDY') return `${MM}/${DD}/${YYYY} ${hh}:${mm}`;
      if (df==='DMY') return `${DD}/${MM}/${YYYY} ${hh}:${mm}`;
      if (df==='D.M.Y') return `${DD}.${MM}.${YYYY} ${hh}:${mm}`;
      if (df==='YMD') return `${YYYY}-${MM}-${DD} ${hh}:${mm}`;
      return `${DD}/${MM}/${YYYY} ${hh}:${mm}`;
    }

    function formatInTZ(date, tz, lang){
      try {
        return new Intl.DateTimeFormat(lang, { timeZone: tz, year:'numeric', month:'long', day:'2-digit', hour:'2-digit', minute:'2-digit', hour12:false, weekday:'short', timeZoneName:'short' }).format(date);
      } catch { return date.toUTCString(); }
    }

    // init
    init();
  </script>
</body>
</html>
