<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –ê–ª–µ–∫—Å–∞–Ω–¥—Ä—ã</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f8;
      color: #222;
    }
    header {
      padding: 12px 20px;
      background: #ffffff;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .lang-switch button {
      margin-left: 6px;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
    }
    .lang-switch button.active {
      background: #222;
      color: #fff;
      border-color: #222;
    }
    main {
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 16px 30px;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      gap: 20px;
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
    }
    .card {
      background: #fff;
      border-radius: 12px;
      padding: 16px 18px 18px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    }
    h2 {
      margin-top: 0;
      font-size: 18px;
    }
    .field-row {
      margin: 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    input[type="file"] {
      max-width: 100%;
    }
    button.primary {
      background: #3b82f6;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 6px 14px;
      font-size: 14px;
      cursor: pointer;
    }
    button.primary:disabled {
      opacity: 0.6;
      cursor: default;
    }
    .status {
      margin-top: 8px;
      font-size: 14px;
      min-height: 18px;
    }
    .progress-bar {
      margin-top: 10px;
      width: 100%;
      height: 14px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
    }
    .progress-bar-inner {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #3b82f6, #22c55e);
      transition: width 0.1s linear;
    }
    .small-text {
      font-size: 12px;
      color: #666;
      margin-top: 6px;
      line-height: 1.4;
    }
    .errors {
      margin-top: 10px;
      font-size: 13px;
      color: #b91c1c;
      max-height: 150px;
      overflow-y: auto;
      border-top: 1px dashed #fbbf24;
      padding-top: 6px;
    }
    .errors ul {
      padding-left: 18px;
      margin: 4px 0;
    }
    .errors li {
      margin: 2px 0;
      word-break: break-all;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      background: #eff6ff;
      color: #1d4ed8;
      margin-top: 4px;
    }
    .chip span {
      margin-left: 4px;
      font-weight: 600;
    }
    .game-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }
    .game-tabs button {
      flex: 1 1 45%;
      border: 1px solid #ccc;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 12px;
      background: #f9fafb;
      cursor: pointer;
      white-space: nowrap;
    }
    .game-tabs button.active {
      background: #22c55e;
      border-color: #16a34a;
      color: #fff;
    }
    #game-container {
      border-radius: 10px;
      background: #f9fafb;
      min-height: 260px;
      padding: 10px;
      position: relative;
      overflow: hidden;
    }
    .game-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 6px;
    }
    canvas {
      background: #0f172a;
      border-radius: 8px;
      display: block;
      margin: 6px auto 0;
    }
  </style>
</head>
<body>
<header>
  <div id="header-title">–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –ê–ª–µ–∫—Å–∞–Ω–¥—Ä—ã</div>
  <div class="lang-switch">
    <span id="lang-label">–Ø–∑—ã–∫:</span>
    <button id="btn-ru" class="active">–†—É—Å—Å–∫–∏–π</button>
    <button id="btn-en">English</button>
  </div>
</header>

<main>
  <!-- –ó–ê–ì–†–£–ó–ö–ê –§–ê–ô–õ–û–í -->
  <section class="card">
    <h2 id="upload-title">–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤</h2>
    <div class="field-row">
      <input type="file" id="file-input" multiple />
      <button class="primary" id="btn-upload">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
      <button class="primary" id="btn-retry" style="display:none;"></button>
    </div>
    <div class="chip" id="file-count-chip" style="display:none;">
      <span id="file-count-text"></span>
    </div>
    <div class="progress-bar">
      <div class="progress-bar-inner" id="progress-inner"></div>
    </div>
    <div class="status" id="status-text"></div>
    <div class="small-text" id="hint-text">
      –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ –≤–∫–ª–∞–¥–∫—É, –ø–æ–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è.
    </div>
    <div class="errors" id="errors-block" style="display:none;">
      <div id="errors-title"></div>
      <ul id="errors-list"></ul>
    </div>
  </section>

  <!-- –ò–ì–†–´ -->
  <section class="card">
    <h2 id="games-title">–ú–∏–Ω–∏-–∏–≥—Ä—ã, —á—Ç–æ–±—ã —Å–∫–æ—Ä–æ—Ç–∞—Ç—å –æ–∂–∏–¥–∞–Ω–∏–µ</h2>
    <div class="small-text" id="games-desc">
      –§–∞–π–ª—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –≤ —Ñ–æ–Ω–µ. –ú–æ–∂–µ—Ç–µ —Å–ø–æ–∫–æ–π–Ω–æ –ø–æ–∏–≥—Ä–∞—Ç—å, –ø–æ–∫–∞ –∂–¥—ë—Ç–µ.
    </div>
    <div class="game-tabs">
      <button data-game="puzzle" id="tab-puzzle" class="active">üß© –ü–∞–∑–ª</button>
      <button data-game="tetris" id="tab-tetris">üü¶ –¢–µ—Ç—Ä–∏—Å</button>
      <button data-game="game2048" id="tab-2048">2048</button>
      <button data-game="flappy" id="tab-flappy">üê§ Flappy</button>
      <button data-game="snake" id="tab-snake">üêç Snake</button>
      <button data-game="memory" id="tab-memory">üÉè Memory</button>
      <button data-game="bubble" id="tab-bubble">ü´ß Bubble</button>
      <button data-game="number" id="tab-number">üî¢ Number</button>
      <button data-game="bounce" id="tab-bounce">üß± Bounce</button>
      <button data-game="orbit" id="tab-orbit">ü™ê Orbit</button>
    </div>
    <div id="game-container"></div>
  </section>
</main>

<script>
  // ========= –ù–ê–°–¢–†–û–ô–ö–ò =========
  const FUNCTION_URL = "https://functions.yandexcloud.net/d4eafltkn2hkceg16of4"; // <-- –ø–æ–¥—Å—Ç–∞–≤—å —Å–≤–æ–π URL, –µ—Å–ª–∏ –æ–Ω –¥—Ä—É–≥–æ–π
  const SECRET = "f7bzlvqi"; // <-- –ø–æ–¥—Å—Ç–∞–≤—å —Ç–æ—Ç –∂–µ —Å–µ–∫—Ä–µ—Ç, —á—Ç–æ –≤ UPLOAD_SECRET

  // ========= –ü–ï–†–ï–í–û–î–´ =========
  const translations = {
    ru: {
      headerTitle: "–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –ê–ª–µ–∫—Å–∞–Ω–¥—Ä—ã",
      langLabel: "–Ø–∑—ã–∫:",
      uploadTitle: "–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤",
      chooseFiles: "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª—ã",
      uploadBtn: "–ó–∞–≥—Ä—É–∑–∏—Ç—å",
      retryBtn: "–ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ",
      statusIdle: "–§–∞–π–ª—ã –Ω–µ –≤—ã–±—Ä–∞–Ω—ã.",
      statusReady: (n) => `–§–∞–π–ª–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏: ${n}.`,
      statusStarting: "–ù–∞—á–∏–Ω–∞—é –∑–∞–≥—Ä—É–∑–∫—É‚Ä¶",
      statusFile: (cur, total, name) =>
        `–°–µ–π—á–∞—Å –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è: ${cur}/${total} ‚Äî ${name}`,
      statusDoneAll: (ok, total, sizeText) =>
        `–ì–æ—Ç–æ–≤–æ! –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${ok} –∏–∑ ${total} —Ñ–∞–π–ª–æ–≤ (${sizeText}).`,
      statusDonePartial: (ok, total, sizeText, failed) =>
        `–ó–∞–≥—Ä—É–∂–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ: ${ok} –∏–∑ ${total} —Ñ–∞–π–ª–æ–≤ (${sizeText}). –ù–µ —É–¥–∞–ª–æ—Å—å: ${failed}.`,
      statusRetry: (count) => `–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ ${count} –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤‚Ä¶`,
      sizeHint: "–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Å—É–º–º–∞—Ä–Ω—ã–π —Ä–∞–∑–º–µ—Ä ‚Äî –¥–æ 35‚Äì40 –ì–ë.",
      dontClose: "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ –≤–∫–ª–∞–¥–∫—É, –ø–æ–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è.",
      errorsTitle: (n) =>
        n === 1 ? "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å 1 —Ñ–∞–π–ª:" : `–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å ${n} —Ñ–∞–π–ª–æ–≤:`,
      gamesTitle: "–ú–∏–Ω–∏-–∏–≥—Ä—ã, —á—Ç–æ–±—ã —Å–∫–æ—Ä–æ—Ç–∞—Ç—å –æ–∂–∏–¥–∞–Ω–∏–µ",
      gamesDesc: "–§–∞–π–ª—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –≤ —Ñ–æ–Ω–µ. –ú–æ–∂–µ—Ç–µ —Å–ø–æ–∫–æ–π–Ω–æ –ø–æ–∏–≥—Ä–∞—Ç—å, –ø–æ–∫–∞ –∂–¥—ë—Ç–µ.",
      gamePuzzle: "üß© –ü–∞–∑–ª",
      gameTetris: "üü¶ –¢–µ—Ç—Ä–∏—Å",
      game2048: "2048",
      gameFlappy: "üê§ Flappy",
      gameSnake: "üêç –ó–º–µ–π–∫–∞",
      gameMemory: "üÉè Memory",
      gameBubble: "ü´ß –ü—É–∑—ã—Ä—å–∫–∏",
      gameNumber: "üî¢ –ß–∏—Å–ª–∞",
      gameBounce: "üß± Bounce",
      gameOrbit: "ü™ê Orbit",
      puzzleTitle: "–ü—è—Ç–Ω–∞—à–∫–∏ 4√ó4",
      puzzleHint: "–ö–ª–∏–∫–∞–π—Ç–µ –ø–æ –ø–ª–∏—Ç–∫–∞–º —Ä—è–¥–æ–º —Å –ø—É—Å—Ç–æ–π, —á—Ç–æ–±—ã —Å–æ–±—Ä–∞—Ç—å —á–∏—Å–ª–∞ –ø–æ –ø–æ—Ä—è–¥–∫—É.",
      tetrisTitle: "–ú–∏–Ω–∏-—Ç–µ—Ç—Ä–∏—Å",
      tetrisHint: "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üê ‚Üí ‚Üì, –ø—Ä–æ–±–µ–ª ‚Äî –ø–æ–≤–µ—Ä–Ω—É—Ç—å —Ñ–∏–≥—É—Ä—É.",
      game2048Title: "2048",
      game2048Hint: "–°–æ–µ–¥–∏–Ω—è–π—Ç–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–ª–∏—Ç–∫–∏ —Å—Ç—Ä–µ–ª–∫–∞–º–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å 2048.",
      flappyTitle: "–ú–∏–Ω–∏ Flappy",
      flappyHint: "–ù–∞–∂–∏–º–∞–π—Ç–µ –ø—Ä–æ–±–µ–ª –∏–ª–∏ –∫–ª–∏–∫–∞–π—Ç–µ –ø–æ –ø–æ–ª—é, —á—Ç–æ–±—ã –ø—Ç–∏—á–∫–∞ –Ω–µ –≤—Ä–µ–∑–∞–ª–∞—Å—å –≤ —Ç—Ä—É–±—ã.",
      snakeTitle: "–ó–º–µ–π–∫–∞",
      snakeHint: "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: —Å—Ç—Ä–µ–ª–∫–∏. –ï—à—å—Ç–µ –µ–¥—É, –Ω–µ –≤—Ä–µ–∑–∞–π—Ç–µ—Å—å –≤ —Å—Ç–µ–Ω—ã –∏ —Ö–≤–æ—Å—Ç.",
      memoryTitle: "–ü–æ–∏—Å–∫ –ø–∞—Ä",
      memoryHint: "–û—Ç–∫—Ä—ã–≤–∞–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –∏ –Ω–∞—Ö–æ–¥–∏—Ç–µ –ø–∞—Ä—ã.",
      bubbleTitle: "–õ–æ–ø–∞–π –ø—É–∑—ã—Ä—å–∫–∏",
      bubbleHint: "–ö–ª–∏–∫–∞–π—Ç–µ –ø–æ –ø—É–∑—ã—Ä—å–∫–∞–º, –ø–æ–∫–∞ –æ–Ω–∏ –Ω–µ –∏—Å—á–µ–∑–ª–∏.",
      numberTitle: "–ß–∏—Å–ª–∞ –ø–æ –ø–æ—Ä—è–¥–∫—É",
      numberHint: "–ö–ª–∏–∫–∞–π—Ç–µ –ø–æ —á–∏—Å–ª–∞–º –æ—Ç 1 –¥–æ 25 –∫–∞–∫ –º–æ–∂–Ω–æ –±—ã—Å—Ç—Ä–µ–µ.",
      bounceTitle: "–ú–∏–Ω–∏ –∞—Ä–∫–∞–Ω–æ–∏–¥",
      bounceHint: "–î–≤–∏–≥–∞–π—Ç–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É (‚Üê ‚Üí), —á—Ç–æ–±—ã –æ—Ç–±–∏–≤–∞—Ç—å –º—è—á –∏ –ª–æ–º–∞—Ç—å –±–ª–æ–∫–∏.",
      orbitTitle: "–ö–ª–∏–∫–∞–µ–º –ø–æ –æ—Ä–±–∏—Ç–∞–º",
      orbitHint: "–ö–ª–∏–∫–∞–π—Ç–µ –ø–æ –ª–µ—Ç–∞—é—â–∏–º —Ç–æ—á–∫–∞–º, –ø–æ–∫–∞ –æ–Ω–∏ –Ω–µ —É–ª–µ—Ç–µ–ª–∏.",
      filesChip: (n) => `–í—ã–±—Ä–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: ${n}`
    },
    en: {
      headerTitle: "File upload for Alexandra",
      langLabel: "Language:",
      uploadTitle: "File upload",
      chooseFiles: "Choose files",
      uploadBtn: "Upload",
      retryBtn: "Retry failed only",
      statusIdle: "No files selected.",
      statusReady: (n) => `Files to upload: ${n}.`,
      statusStarting: "Starting upload‚Ä¶",
      statusFile: (cur, total, name) =>
        `Uploading: ${cur}/${total} ‚Äî ${name}`,
      statusDoneAll: (ok, total, sizeText) =>
        `Done! Uploaded ${ok} of ${total} files (${sizeText}).`,
      statusDonePartial: (ok, total, sizeText, failed) =>
        `Uploaded successfully: ${ok} of ${total} files (${sizeText}). Failed: ${failed}.`,
      statusRetry: (count) => `Retrying upload of ${count} failed files‚Ä¶`,
      sizeHint: "Recommended total size: up to about 35‚Äì40 GB.",
      dontClose: "Please do not close this tab until the upload is finished.",
      errorsTitle: (n) =>
        n === 1 ? "Failed to upload 1 file:" : `Failed to upload ${n} files:`,
      gamesTitle: "Mini games to pass the time",
      gamesDesc: "Files are uploading in the background. Feel free to play while you wait.",
      gamePuzzle: "üß© Puzzle",
      gameTetris: "üü¶ Tetris",
      game2048: "2048",
      gameFlappy: "üê§ Flappy",
      gameSnake: "üêç Snake",
      gameMemory: "üÉè Memory",
      gameBubble: "ü´ß Bubble",
      gameNumber: "üî¢ Numbers",
      gameBounce: "üß± Bounce",
      gameOrbit: "ü™ê Orbit",
      puzzleTitle: "15 Puzzle 4√ó4",
      puzzleHint: "Click tiles next to the empty one to arrange numbers in order.",
      tetrisTitle: "Mini Tetris",
      tetrisHint: "Controls: ‚Üê ‚Üí ‚Üì, space ‚Äî rotate.",
      game2048Title: "2048",
      game2048Hint: "Merge tiles with the same number using arrow keys to reach 2048.",
      flappyTitle: "Mini Flappy",
      flappyHint: "Press space or click to keep the bird between the pipes.",
      snakeTitle: "Snake",
      snakeHint: "Controls: arrows. Eat food, avoid walls and your tail.",
      memoryTitle: "Memory",
      memoryHint: "Flip cards to find matching pairs.",
      bubbleTitle: "Bubble Pop",
      bubbleHint: "Click bubbles before they disappear.",
      numberTitle: "Number Rush",
      numberHint: "Click numbers from 1 to 25 as fast as you can.",
      bounceTitle: "Mini Arkanoid",
      bounceHint: "Move the paddle (‚Üê ‚Üí) to bounce the ball and break bricks.",
      orbitTitle: "Orbit Clicker",
      orbitHint: "Click flying dots on orbits before they pass by.",
      filesChip: (n) => `Files selected: ${n}`
    }
  };

  let currentLang = "ru";

  // –≠–ª–µ–º–µ–Ω—Ç—ã
  const headerTitleEl = document.getElementById("header-title");
  const langLabelEl = document.getElementById("lang-label");
  const btnRu = document.getElementById("btn-ru");
  const btnEn = document.getElementById("btn-en");

  const uploadTitleEl = document.getElementById("upload-title");
  const btnUpload = document.getElementById("btn-upload");
  const btnRetry = document.getElementById("btn-retry");
  const statusTextEl = document.getElementById("status-text");
  const hintTextEl = document.getElementById("hint-text");
  const progressInner = document.getElementById("progress-inner");
  const fileInput = document.getElementById("file-input");
  const errorsBlock = document.getElementById("errors-block");
  const errorsTitleEl = document.getElementById("errors-title");
  const errorsListEl = document.getElementById("errors-list");
  const fileCountChip = document.getElementById("file-count-chip");
  const fileCountText = document.getElementById("file-count-text");

  const gamesTitleEl = document.getElementById("games-title");
  const gamesDescEl = document.getElementById("games-desc");
  const tabPuzzle = document.getElementById("tab-puzzle");
  const tabTetris = document.getElementById("tab-tetris");
  const tab2048 = document.getElementById("tab-2048");
  const tabFlappy = document.getElementById("tab-flappy");
  const tabSnake = document.getElementById("tab-snake");
  const tabMemory = document.getElementById("tab-memory");
  const tabBubble = document.getElementById("tab-bubble");
  const tabNumber = document.getElementById("tab-number");
  const tabBounce = document.getElementById("tab-bounce");
  const tabOrbit = document.getElementById("tab-orbit");
  const gameContainer = document.getElementById("game-container");

  // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏
  let allFiles = [];
  let failedFiles = [];
  let isUploading = false;

  function formatSize(bytes) {
    const units = ["–ë", "–ö–ë", "–ú–ë", "–ì–ë", "–¢–ë"];
    const unitsEn = ["B", "KB", "MB", "GB", "TB"];
    const u = currentLang === "ru" ? units : unitsEn;
    if (bytes === 0) return "0 " + u[0];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    const value = (bytes / Math.pow(1024, i)).toFixed(1);
    return `${value} ${u[i]}`;
  }

  function updateLanguage(lang) {
    currentLang = lang;
    const t = translations[lang];

    headerTitleEl.textContent = t.headerTitle;
    langLabelEl.textContent = t.langLabel;
    uploadTitleEl.textContent = t.uploadTitle;
    btnUpload.textContent = t.uploadBtn;
    btnRetry.textContent = t.retryBtn;
    hintTextEl.textContent = t.dontClose + " " + t.sizeHint;

    gamesTitleEl.textContent = t.gamesTitle;
    gamesDescEl.textContent = t.gamesDesc;

    tabPuzzle.textContent = t.gamePuzzle;
    tabTetris.textContent = t.gameTetris;
    tab2048.textContent = t.game2048;
    tabFlappy.textContent = t.gameFlappy;
    tabSnake.textContent = t.gameSnake;
    tabMemory.textContent = t.gameMemory;
    tabBubble.textContent = t.gameBubble;
    tabNumber.textContent = t.gameNumber;
    tabBounce.textContent = t.gameBounce;
    tabOrbit.textContent = t.gameOrbit;

    if (allFiles.length === 0) {
      statusTextEl.textContent = t.statusIdle;
      fileCountChip.style.display = "none";
    } else {
      statusTextEl.textContent = t.statusReady(allFiles.length);
      fileCountChip.style.display = "inline-flex";
      fileCountText.textContent = t.filesChip(allFiles.length);
    }

    if (failedFiles.length > 0) {
      errorsTitleEl.textContent = t.errorsTitle(failedFiles.length);
    }

    btnRu.classList.toggle("active", lang === "ru");
    btnEn.classList.toggle("active", lang === "en");

    const activeGame = document.querySelector(".game-tabs button.active")?.dataset.game || "puzzle";
    safeLoadGame(activeGame);
  }

  (function initLang() {
    const saved = localStorage.getItem("upload_lang");
    if (saved === "ru" || saved === "en") {
      currentLang = saved;
    } else {
      const navLang = (navigator.language || "en").toLowerCase();
      currentLang = navLang.startsWith("ru") ? "ru" : "en";
    }
    updateLanguage(currentLang);
  })();

  btnRu.addEventListener("click", () => {
    localStorage.setItem("upload_lang", "ru");
    updateLanguage("ru");
  });
  btnEn.addEventListener("click", () => {
    localStorage.setItem("upload_lang", "en");
    updateLanguage("en");
  });

  fileInput.addEventListener("change", () => {
    allFiles = Array.from(fileInput.files || []);
    const t = translations[currentLang];
    if (allFiles.length === 0) {
      statusTextEl.textContent = t.statusIdle;
      fileCountChip.style.display = "none";
    } else {
      statusTextEl.textContent = t.statusReady(allFiles.length);
      fileCountChip.style.display = "inline-flex";
      fileCountText.textContent = t.filesChip(allFiles.length);
    }
    progressInner.style.width = "0%";
    errorsBlock.style.display = "none";
    errorsListEl.innerHTML = "";
    failedFiles = [];
  });

  async function uploadFiles(filesToUpload, isRetry = false) {
    if (!filesToUpload.length) return;
    const t = translations[currentLang];

    isUploading = true;
    btnUpload.disabled = true;
    btnRetry.style.display = "none";
    errorsBlock.style.display = "none";
    errorsListEl.innerHTML = "";
    failedFiles = [];

    const totalFiles = filesToUpload.length;
    let uploadedCount = 0;
    let uploadedBytes = 0;
    const totalSize = filesToUpload.reduce((s, f) => s + f.size, 0);

    statusTextEl.textContent = isRetry
      ? t.statusRetry(totalFiles)
      : t.statusStarting;
    progressInner.style.width = "0%";

    for (let i = 0; i < filesToUpload.length; i++) {
      const file = filesToUpload[i];
      const currentIndex = i + 1;
      statusTextEl.textContent = t.statusFile(currentIndex, totalFiles, file.name);

      try {
        const metaResp = await fetch(FUNCTION_URL + "?key=" + encodeURIComponent(SECRET), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            filename: file.name,
            size: file.size,
            contentType: file.type || "application/octet-stream",
          }),
        });
        if (!metaResp.ok) {
          throw new Error("Meta request failed: " + metaResp.status);
        }
        const metaData = await metaResp.json();
        const uploadUrl = metaData.upload_url;
        if (!uploadUrl) {
          throw new Error("No upload_url");
        }

        await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("PUT", uploadUrl, true);
          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable && totalSize > 0) {
              const currentUploaded = uploadedBytes + e.loaded;
              const percent = (currentUploaded / totalSize) * 100;
              progressInner.style.width = Math.min(100, percent).toFixed(1) + "%";
            }
          };
          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              uploadedBytes += file.size;
              const percent = (uploadedBytes / totalSize) * 100;
              progressInner.style.width = Math.min(100, percent).toFixed(1) + "%";
              resolve();
            } else {
              reject(new Error("Upload failed: " + xhr.status));
            }
          };
          xhr.onerror = () => reject(new Error("Network error"));
          xhr.setRequestHeader("Content-Type", file.type || "application/octet-stream");
          xhr.send(file);
        });

        uploadedCount += 1;
      } catch (err) {
        console.error("Error uploading file", file.name, err);
        failedFiles.push({ file, reason: err.message || "Error" });
      }
    }

    const sizeText = formatSize(uploadedBytes);
    if (failedFiles.length === 0) {
      statusTextEl.textContent = t.statusDoneAll(uploadedCount, totalFiles, sizeText);
    } else {
      statusTextEl.textContent = t.statusDonePartial(
        uploadedCount,
        totalFiles,
        sizeText,
        failedFiles.length
      );
      errorsTitleEl.textContent = t.errorsTitle(failedFiles.length);
      errorsListEl.innerHTML = "";
      failedFiles.forEach((f) => {
        const li = document.createElement("li");
        li.textContent = `${f.file.name} ‚Äî ${f.reason}`;
        errorsListEl.appendChild(li);
      });
      errorsBlock.style.display = "block";
      btnRetry.style.display = "inline-block";
    }

    btnUpload.disabled = false;
    isUploading = false;
  }

  btnUpload.addEventListener("click", () => {
    const t = translations[currentLang];
    if (!allFiles.length) {
      statusTextEl.textContent = t.statusIdle;
      return;
    }
    const totalSize = allFiles.reduce((s, f) => s + f.size, 0);
    const maxRecommended = 40 * 1024 * 1024 * 1024;
    if (totalSize > maxRecommended) {
      alert(t.sizeHint + "\n" + "( " + formatSize(totalSize) + " )");
    }
    uploadFiles(allFiles, false);
  });

  btnRetry.addEventListener("click", () => {
    if (!failedFiles.length) return;
    const retryList = failedFiles.map((x) => x.file);
    uploadFiles(retryList, true);
  });

  // ========= –ò–ì–†–´ =========
  function clearGameContainer() {
    if (typeof gameContainer._cleanup === "function") {
      try { gameContainer._cleanup(); } catch(e) {}
      gameContainer._cleanup = null;
    }
    gameContainer.innerHTML = "";
  }

  function setActiveTab(name) {
    [tabPuzzle, tabTetris, tab2048, tabFlappy, tabSnake, tabMemory, tabBubble, tabNumber, tabBounce, tabOrbit]
      .forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.game === name);
      });
  }

  function loadGame(name) {
    const t = translations[currentLang];
    clearGameContainer();
    setActiveTab(name);

    // ------- –ü–ê–ó–õ -------
    if (name === "puzzle") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.puzzleTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.puzzleHint;
      const grid = document.createElement("div");
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = "repeat(4, 1fr)";
      grid.style.gap = "4px";
      grid.style.marginTop = "8px";

      const tiles = [];
      for (let i = 1; i <= 15; i++) tiles.push(i);
      tiles.push(null);
      for (let i = tiles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
      }

      function renderTiles() {
        grid.innerHTML = "";
        tiles.forEach((val, idx) => {
          const cell = document.createElement("div");
          cell.style.height = "40px";
          cell.style.display = "flex";
          cell.style.alignItems = "center";
          cell.style.justifyContent = "center";
          cell.style.borderRadius = "8px";
          cell.style.cursor = "pointer";
          cell.style.fontSize = "14px";

          if (val === null) {
            cell.style.background = "#e5e7eb";
            cell.textContent = "";
          } else {
            cell.style.background = "#3b82f6";
            cell.style.color = "#fff";
            cell.textContent = val;
          }

          cell.addEventListener("click", () => {
            if (val === null) return;
            const emptyIndex = tiles.indexOf(null);
            const row = Math.floor(idx / 4);
            const col = idx % 4;
            const er = Math.floor(emptyIndex / 4);
            const ec = emptyIndex % 4;
            const isNeighbour =
              (row === er && Math.abs(col - ec) === 1) ||
              (col === ec && Math.abs(row - er) === 1);
            if (isNeighbour) {
              [tiles[idx], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[idx]];
              renderTiles();
            }
          });

          grid.appendChild(cell);
        });
      }

      renderTiles();
      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(grid);
      return;
    }

    // ------- –¢–ï–¢–†–ò–° -------
    if (name === "tetris") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.tetrisTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.tetrisHint;
      const canvas = document.createElement("canvas");
      canvas.width = 200;
      canvas.height = 380;
      const ctx = canvas.getContext("2d");

      const cols = 10;
      const rows = 19;
      const size = 20;
      const board = Array.from({ length: rows }, () => Array(cols).fill(0));
      const shapes = [
        [[1, 1, 1, 1]],
        [[1, 1], [1, 1]],
        [[0, 1, 0], [1, 1, 1]],
        [[1, 0, 0], [1, 1, 1]],
        [[0, 0, 1], [1, 1, 1]],
        [[1, 1, 0], [0, 1, 1]],
        [[0, 1, 1], [1, 1, 0]],
      ];

      function randomShape() {
        const shape = shapes[Math.floor(Math.random() * shapes.length)];
        return shape.map((row) => [...row]);
      }

      let piece = { shape: randomShape(), row: 0, col: 3 };

      function rotate(shape) {
        const rows = shape.length;
        const cols = shape[0].length;
        const res = [];
        for (let c = 0; c < cols; c++) {
          const newRow = [];
          for (let r = rows - 1; r >= 0; r--) {
            newRow.push(shape[r][c]);
          }
          res.push(newRow);
        }
        return res;
      }

      function collides(p) {
        const { shape, row, col } = p;
        for (let r = 0; r < shape.length; r++) {
          for (let c = 0; c < shape[r].length; c++) {
            if (!shape[r][c]) continue;
            const nr = row + r;
            const nc = col + c;
            if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) return true;
            if (board[nr][nc]) return true;
          }
        }
        return false;
      }

      function mergePiece() {
        const { shape, row, col } = piece;
        for (let r = 0; r < shape.length; r++) {
          for (let c = 0; c < shape[r].length; c++) {
            if (shape[r][c]) {
              const nr = row + r;
              const nc = col + c;
              if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                board[nr][nc] = 1;
              }
            }
          }
        }
        for (let r = rows - 1; r >= 0; r--) {
          if (board[r].every((v) => v === 1)) {
            board.splice(r, 1);
            board.unshift(Array(cols).fill(0));
            r++;
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (board[r][c]) {
              ctx.fillStyle = "#22c55e";
              ctx.fillRect(c * size, r * size, size - 1, size - 1);
            }
          }
        }
        ctx.fillStyle = "#3b82f6";
        const { shape, row, col } = piece;
        for (let r = 0; r < shape.length; r++) {
          for (let c = 0; c < shape[r].length; c++) {
            if (shape[r][c]) {
              const nr = row + r;
              const nc = col + c;
              ctx.fillRect(nc * size, nr * size, size - 1, size - 1);
            }
          }
        }
      }

      let gameOver = false;
      function tick() {
        if (gameOver) return;
        const newPiece = { shape: piece.shape, row: piece.row + 1, col: piece.col };
        if (!collides(newPiece)) {
          piece = newPiece;
        } else {
          mergePiece();
          piece = { shape: randomShape(), row: 0, col: 3 };
          if (collides(piece)) {
            gameOver = true;
          }
        }
        draw();
      }
      const interval = setInterval(tick, 500);

      function handleKey(e) {
        if (["ArrowLeft", "ArrowRight", "ArrowDown", " "].includes(e.key)) e.preventDefault();
        if (gameOver) return;
        if (e.key === "ArrowLeft") {
          const p = { ...piece, col: piece.col - 1 };
          if (!collides(p)) piece = p;
        } else if (e.key === "ArrowRight") {
          const p = { ...piece, col: piece.col + 1 };
          if (!collides(p)) piece = p;
        } else if (e.key === "ArrowDown") {
          const p = { ...piece, row: piece.row + 1 };
          if (!collides(p)) piece = p;
        } else if (e.key === " ") {
          const p = { ...piece, shape: rotate(piece.shape) };
          if (!collides(p)) piece = p;
        }
        draw();
      }

      document.addEventListener("keydown", handleKey);
      gameContainer._cleanup = () => {
        clearInterval(interval);
        document.removeEventListener("keydown", handleKey);
      };

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(canvas);
      draw();
      return;
    }

    // ------- 2048 -------
    if (name === "game2048") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.game2048Title;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.game2048Hint;

      const size = 4;
      let board = Array.from({ length: size }, () => Array(size).fill(0));

      const container = document.createElement("div");
      container.style.display = "grid";
      container.style.gridTemplateColumns = "repeat(4, 1fr)";
      container.style.gap = "4px";
      container.style.marginTop = "8px";

      function addRandomTile() {
        const empty = [];
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (board[r][c] === 0) empty.push([r, c]);
          }
        }
        if (!empty.length) return;
        const [r, c] = empty[Math.floor(Math.random() * empty.length)];
        board[r][c] = Math.random() < 0.9 ? 2 : 4;
      }

      function drawBoard() {
        container.innerHTML = "";
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const cell = document.createElement("div");
            cell.style.height = "45px";
            cell.style.display = "flex";
            cell.style.alignItems = "center";
            cell.style.justifyContent = "center";
            cell.style.borderRadius = "6px";
            cell.style.fontWeight = "600";
            cell.style.fontSize = "14px";
            const val = board[r][c];
            if (val === 0) {
              cell.style.background = "#e5e7eb";
              cell.textContent = "";
            } else {
              cell.style.background = "#3b82f6";
              cell.style.color = "#fff";
              cell.textContent = val;
            }
            container.appendChild(cell);
          }
        }
      }

      function slideRow(row) {
        const arr = row.filter(v => v !== 0);
        for (let i = 0; i < arr.length - 1; i++) {
          if (arr[i] === arr[i + 1]) {
            arr[i] *= 2;
            arr[i + 1] = 0;
          }
        }
        return arr.filter(v => v !== 0);
      }

      function moveLeft() {
        let changed = false;
        for (let r = 0; r < size; r++) {
          const row = board[r];
          const newRow = slideRow(row);
          while (newRow.length < size) newRow.push(0);
          if (newRow.toString() !== row.toString()) changed = true;
          board[r] = newRow;
        }
        if (changed) addRandomTile();
        drawBoard();
      }

      function moveRight() {
        let changed = false;
        for (let r = 0; r < size; r++) {
          const row = [...board[r]].reverse();
          const newRow = slideRow(row);
          while (newRow.length < size) newRow.push(0);
          newRow.reverse();
          if (newRow.toString() !== board[r].toString()) changed = true;
          board[r] = newRow;
        }
        if (changed) addRandomTile();
        drawBoard();
      }

      function moveUp() {
        let changed = false;
        for (let c = 0; c < size; c++) {
          const col = [];
          for (let r = 0; r < size; r++) col.push(board[r][c]);
          const newCol = slideRow(col);
          while (newCol.length < size) newCol.push(0);
          for (let r = 0; r < size; r++) {
            if (board[r][c] !== newCol[r]) changed = true;
            board[r][c] = newCol[r];
          }
        }
        if (changed) addRandomTile();
        drawBoard();
      }

      function moveDown() {
        let changed = false;
        for (let c = 0; c < size; c++) {
          const col = [];
          for (let r = 0; r < size; r++) col.push(board[r][c]);
          col.reverse();
          const newCol = slideRow(col);
          while (newCol.length < size) newCol.push(0);
          newCol.reverse();
          for (let r = 0; r < size; r++) {
            if (board[r][c] !== newCol[r]) changed = true;
            board[r][c] = newCol[r];
          }
        }
        if (changed) addRandomTile();
        drawBoard();
      }

      function handleKey(e) {
        if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)) {
          e.preventDefault();
        }
        if (e.key === "ArrowLeft") moveLeft();
        else if (e.key === "ArrowRight") moveRight();
        else if (e.key === "ArrowUp") moveUp();
        else if (e.key === "ArrowDown") moveDown();
      }

      document.addEventListener("keydown", handleKey);
      gameContainer._cleanup = () => {
        document.removeEventListener("keydown", handleKey);
      };

      addRandomTile();
      addRandomTile();
      drawBoard();

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(container);
      return;
    }

    // ------- FLAPPY -------
    if (name === "flappy") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.flappyTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.flappyHint;

      const canvas = document.createElement("canvas");
      canvas.width = 260;
      canvas.height = 220;
      const ctx = canvas.getContext("2d");

      let y = canvas.height / 2;
      let vel = 0;
      const gravity = 0.4;
      const jump = -6;
      let pipes = [];
      let frame = 0;
      let score = 0;
      let gameOver = false;

      function spawnPipe() {
        const gap = 70;
        const min = 30;
        const max = canvas.height - gap - 30;
        const top = Math.floor(Math.random() * (max - min)) + min;
        pipes.push({ x: canvas.width, top });
      }

      function draw() {
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#22c55e";
        pipes.forEach(p => {
          ctx.fillRect(p.x, 0, 30, p.top);
          ctx.fillRect(p.x, p.top + 70, 30, canvas.height - (p.top + 70));
        });

        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(60, y, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "12px sans-serif";
        ctx.fillText("Score: " + score, 10, 15);

        if (gameOver) {
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#fff";
          ctx.font = "14px sans-serif";
          ctx.fillText("Game Over", 80, 110);
        }
      }

      function tick() {
        if (gameOver) {
          draw();
          return;
        }
        frame++;
        if (frame % 80 === 0) spawnPipe();

        vel += gravity;
        y += vel;

        pipes.forEach(p => p.x -= 2);
        pipes = pipes.filter(p => p.x > -40);

        if (y < 8 || y > canvas.height - 8) {
          gameOver = true;
        }

        pipes.forEach(p => {
          if (60 + 8 > p.x && 60 - 8 < p.x + 30) {
            if (y - 8 < p.top || y + 8 > p.top + 70) {
              gameOver = true;
            }
          }
          if (!gameOver && p.x + 30 === 60) {
            score++;
          }
        });

        draw();
      }

      function flap() {
        if (gameOver) {
          // restart
          y = canvas.height / 2;
          vel = 0;
          pipes = [];
          frame = 0;
          score = 0;
          gameOver = false;
          return;
        }
        vel = jump;
      }

      const interval = setInterval(tick, 30);
      function handleKey(e) {
        if (e.key === " ") {
          e.preventDefault();
          flap();
        }
      }
      function handleClick() {
        flap();
      }

      document.addEventListener("keydown", handleKey);
      canvas.addEventListener("click", handleClick);
      gameContainer._cleanup = () => {
        clearInterval(interval);
        document.removeEventListener("keydown", handleKey);
        canvas.removeEventListener("click", handleClick);
      };

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(canvas);
      draw();
      return;
    }

    // ------- SNAKE -------
    if (name === "snake") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.snakeTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.snakeHint;

      const canvas = document.createElement("canvas");
      canvas.width = 220;
      canvas.height = 220;
      const ctx = canvas.getContext("2d");

      const cell = 11;
      const cols = canvas.width / cell;
      const rows = canvas.height / cell;

      let snake = [{ x: 5, y: 5 }];
      let dir = { x: 1, y: 0 };
      let food = { x: 10, y: 10 };
      let gameOver = false;

      function placeFood() {
        food.x = Math.floor(Math.random() * cols);
        food.y = Math.floor(Math.random() * rows);
      }

      function draw() {
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#f97316";
        snake.forEach((s, i) => {
          ctx.globalAlpha = i === 0 ? 1 : 0.8;
          ctx.fillRect(s.x * cell, s.y * cell, cell - 1, cell - 1);
        });
        ctx.globalAlpha = 1;

        ctx.fillStyle = "#22c55e";
        ctx.fillRect(food.x * cell, food.y * cell, cell - 1, cell - 1);

        if (gameOver) {
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#fff";
          ctx.font = "14px sans-serif";
          ctx.fillText("Game Over", 70, 110);
        }
      }

      function tick() {
        if (gameOver) {
          draw();
          return;
        }
        const head = { ...snake[0] };
        head.x += dir.x;
        head.y += dir.y;

        if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
          gameOver = true;
          draw();
          return;
        }
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
          gameOver = true;
          draw();
          return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          placeFood();
        } else {
          snake.pop();
        }

        draw();
      }

      const interval = setInterval(tick, 120);

      function handleKey(e) {
        if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault();
        if (e.key === "ArrowUp" && dir.y === 0) dir = { x: 0, y: -1 };
        else if (e.key === "ArrowDown" && dir.y === 0) dir = { x: 0, y: 1 };
        else if (e.key === "ArrowLeft" && dir.x === 0) dir = { x: -1, y: 0 };
        else if (e.key === "ArrowRight" && dir.x === 0) dir = { x: 1, y: 0 };
      }

      document.addEventListener("keydown", handleKey);
      gameContainer._cleanup = () => {
        clearInterval(interval);
        document.removeEventListener("keydown", handleKey);
      };

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(canvas);
      draw();
      return;
    }

    // ------- MEMORY -------
    if (name === "memory") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.memoryTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.memoryHint;

      const grid = document.createElement("div");
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = "repeat(4, 1fr)";
      grid.style.gap = "4px";
      grid.style.marginTop = "8px";

      const icons = ["üçé","üçã","üçì","üçâ","ü•ï","üçá","üçí","ü•ù"];
      let cards = icons.concat(icons).map((icon, idx) => ({
        id: idx,
        icon,
        open: false,
        matched: false
      }));

      for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cards[i], cards[j]] = [cards[j], cards[i]];
      }

      let opened = [];

      function render() {
        grid.innerHTML = "";
        cards.forEach((card, idx) => {
          const cell = document.createElement("div");
          cell.style.height = "45px";
          cell.style.display = "flex";
          cell.style.alignItems = "center";
          cell.style.justifyContent = "center";
          cell.style.borderRadius = "8px";
          cell.style.cursor = card.matched ? "default" : "pointer";
          cell.style.fontSize = "24px";
          cell.style.background = card.matched ? "#22c55e" : "#e5e7eb";
          cell.style.color = card.open || card.matched ? "#111" : "transparent";
          cell.textContent = card.icon;
          cell.addEventListener("click", () => {
            if (card.matched || card.open) return;
            if (opened.length >= 2) return;
            card.open = true;
            opened.push(idx);
            render();
            if (opened.length === 2) {
              const [i1, i2] = opened;
              const c1 = cards[i1];
              const c2 = cards[i2];
              if (c1.icon === c2.icon) {
                c1.matched = c2.matched = true;
                opened = [];
              } else {
                setTimeout(() => {
                  c1.open = false;
                  c2.open = false;
                  opened = [];
                  render();
                }, 700);
              }
            }
          });
          grid.appendChild(cell);
        });
      }

      render();
      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(grid);
      return;
    }

    // ------- BUBBLE POP -------
    if (name === "bubble") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.bubbleTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.bubbleHint;

      const wrap = document.createElement("div");
      wrap.style.position = "relative";
      wrap.style.height = "200px";
      wrap.style.background = "#e0f2fe";
      wrap.style.borderRadius = "8px";
      wrap.style.overflow = "hidden";

      let score = 0;
      const scoreEl = document.createElement("div");
      scoreEl.className = "small-text";
      scoreEl.style.marginTop = "6px";

      function updateScore() {
        scoreEl.textContent =
          currentLang === "ru" ? `–°—á—ë—Ç: ${score}` : `Score: ${score}`;
      }
      updateScore();

      function spawnBubble() {
        const bubble = document.createElement("div");
        const size = 20 + Math.random() * 25;
        bubble.style.width = size + "px";
        bubble.style.height = size + "px";
        bubble.style.borderRadius = "50%";
        bubble.style.border = "2px solid #38bdf8";
        bubble.style.position = "absolute";
        bubble.style.left = Math.random() * (wrap.clientWidth - size) + "px";
        bubble.style.top = wrap.clientHeight + "px";
        bubble.style.boxSizing = "border-box";
        let y = wrap.clientHeight + size;
        const speed = 0.5 + Math.random();
        const id = setInterval(() => {
          y -= speed;
          bubble.style.top = y + "px";
          if (y < -size) {
            clearInterval(id);
            bubble.remove();
          }
        }, 16);

        bubble.addEventListener("click", () => {
          clearInterval(id);
          bubble.remove();
          score++;
          updateScore();
        });

        wrap.appendChild(bubble);
      }

      const interval = setInterval(spawnBubble, 800);
      gameContainer._cleanup = () => {
        clearInterval(interval);
      };

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(wrap);
      gameContainer.appendChild(scoreEl);
      return;
    }

    // ------- NUMBER RUSH -------
    if (name === "number") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.numberTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.numberHint;

      const grid = document.createElement("div");
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = "repeat(5, 1fr)";
      grid.style.gap = "4px";
      grid.style.marginTop = "8px";

      const nums = [];
      for (let i = 1; i <= 25; i++) nums.push(i);
      for (let i = nums.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [nums[i], nums[j]] = [nums[j], nums[i]];
      }

      let target = 1;

      nums.forEach((num) => {
        const cell = document.createElement("div");
        cell.style.height = "35px";
        cell.style.display = "flex";
        cell.style.alignItems = "center";
        cell.style.justifyContent = "center";
        cell.style.borderRadius = "8px";
        cell.style.cursor = "pointer";
        cell.style.fontSize = "14px";
        cell.style.background = "#e5e7eb";
        cell.textContent = num;
        cell.addEventListener("click", () => {
          if (num === target) {
            cell.style.background = "#22c55e";
            cell.style.color = "#fff";
            target++;
          }
        });
        grid.appendChild(cell);
      });

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(grid);
      return;
    }

    // ------- BOUNCE BALL (–º–∏–Ω–∏-–∞—Ä–∫–∞–Ω–æ–∏–¥) -------
    if (name === "bounce") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.bounceTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.bounceHint;

      const canvas = document.createElement("canvas");
      canvas.width = 260;
      canvas.height = 200;
      const ctx = canvas.getContext("2d");

      let paddleX = canvas.width / 2 - 30;
      const paddleW = 60;
      const paddleH = 8;
      let ballX = canvas.width / 2;
      let ballY = canvas.height - 20;
      let ballVX = 2;
      let ballVY = -2;

      const rows = 3;
      const cols = 7;
      const brickW = 30;
      const brickH = 10;
      const brickPadding = 4;
      const brickOffsetTop = 20;
      const brickOffsetLeft = 10;
      const bricks = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          bricks.push({
            x: brickOffsetLeft + c * (brickW + brickPadding),
            y: brickOffsetTop + r * (brickH + brickPadding),
            alive: true
          });
        }
      }

      function draw() {
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#22c55e";
        bricks.forEach(b => {
          if (b.alive) {
            ctx.fillRect(b.x, b.y, brickW, brickH);
          }
        });

        ctx.fillStyle = "#e5e7eb";
        ctx.fillRect(paddleX, canvas.height - 20, paddleW, paddleH);

        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.arc(ballX, ballY, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      function tick() {
        ballX += ballVX;
        ballY += ballVY;

        if (ballX < 5 || ballX > canvas.width - 5) ballVX *= -1;
        if (ballY < 5) ballVY *= -1;

        if (
          ballY > canvas.height - 20 - 5 &&
          ballY < canvas.height &&
          ballX > paddleX &&
          ballX < paddleX + paddleW
        ) {
          ballVY *= -1;
        }

        bricks.forEach(b => {
          if (!b.alive) return;
          if (
            ballX > b.x &&
            ballX < b.x + brickW &&
            ballY > b.y &&
            ballY < b.y + brickH
          ) {
            b.alive = false;
            ballVY *= -1;
          }
        });

        if (ballY > canvas.height + 10) {
          ballX = canvas.width / 2;
          ballY = canvas.height - 20;
          ballVX = 2;
          ballVY = -2;
        }

        draw();
      }

      const interval = setInterval(tick, 16);

      function handleKey(e) {
        if (e.key === "ArrowLeft") {
          paddleX -= 15;
        } else if (e.key === "ArrowRight") {
          paddleX += 15;
        }
        if (paddleX < 0) paddleX = 0;
        if (paddleX + paddleW > canvas.width) paddleX = canvas.width - paddleW;
      }

      document.addEventListener("keydown", handleKey);
      gameContainer._cleanup = () => {
        clearInterval(interval);
        document.removeEventListener("keydown", handleKey);
      };

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(canvas);
      draw();
      return;
    }

    // ------- ORBIT CLICKER -------
    if (name === "orbit") {
      const title = document.createElement("div");
      title.className = "game-title";
      title.textContent = t.orbitTitle;
      const hint = document.createElement("div");
      hint.className = "small-text";
      hint.textContent = t.orbitHint;

      const canvas = document.createElement("canvas");
      canvas.width = 260;
      canvas.height = 200;
      const ctx = canvas.getContext("2d");

      let score = 0;
      function drawScore() {
        ctx.fillStyle = "#fff";
        ctx.font = "12px sans-serif";
        const text = currentLang === "ru" ? `–°—á—ë—Ç: ${score}` : `Score: ${score}`;
        ctx.fillText(text, 10, 15);
      }

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const orbits = [
        { r: 30, speed: 0.04, angle: 0 },
        { r: 50, speed: -0.03, angle: 1 },
        { r: 70, speed: 0.02, angle: 2 }
      ];

      function draw() {
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = "#1e293b";
        orbits.forEach(o => {
          ctx.beginPath();
          ctx.arc(centerX, centerY, o.r, 0, Math.PI * 2);
          ctx.stroke();
        });

        ctx.fillStyle = "#22c55e";
        orbits.forEach(o => {
          const x = centerX + Math.cos(o.angle) * o.r;
          const y = centerY + Math.sin(o.angle) * o.r;
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fill();
        });

        drawScore();
      }

      function tick() {
        orbits.forEach(o => {
          o.angle += o.speed;
        });
        draw();
      }

      function clickHandler(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        orbits.forEach(o => {
          const px = centerX + Math.cos(o.angle) * o.r;
          const py = centerY + Math.sin(o.angle) * o.r;
          const dist = Math.hypot(x - px, y - py);
          if (dist < 8) {
            score++;
          }
        });
      }

      const interval = setInterval(tick, 30);
      canvas.addEventListener("click", clickHandler);
      gameContainer._cleanup = () => {
        clearInterval(interval);
        canvas.removeEventListener("click", clickHandler);
      };

      gameContainer.appendChild(title);
      gameContainer.appendChild(hint);
      gameContainer.appendChild(canvas);
      draw();
      return;
    }
  }

  function safeLoadGame(name) {
    clearGameContainer();
    loadGame(name);
  }

  tabPuzzle.addEventListener("click", () => safeLoadGame("puzzle"));
  tabTetris.addEventListener("click", () => safeLoadGame("tetris"));
  tab2048.addEventListener("click", () => safeLoadGame("game2048"));
  tabFlappy.addEventListener("click", () => safeLoadGame("flappy"));
  tabSnake.addEventListener("click", () => safeLoadGame("snake"));
  tabMemory.addEventListener("click", () => safeLoadGame("memory"));
  tabBubble.addEventListener("click", () => safeLoadGame("bubble"));
  tabNumber.addEventListener("click", () => safeLoadGame("number"));
  tabBounce.addEventListener("click", () => safeLoadGame("bounce"));
  tabOrbit.addEventListener("click", () => safeLoadGame("orbit"));

  safeLoadGame("puzzle");
</script>
</body>
</html>
